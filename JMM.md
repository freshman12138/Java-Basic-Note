# Java内存模型JMM #
2019-03-07 9:01:09 

## 1.JMM ##
java内存模型(java memory model,JMM)本身是一种抽象的概念,并不是真实存在的,他描述的是一种规则或规范,通过这组规范定义了程序中各个变量(包括实例字段,静态字段和构成数组对象的元素)的访问方式

java运行结构模型
![](https://i.imgur.com/NQgAEFT.png)
#### 线程不能直接对主内存的变量进行处理,必须先把主内存的变量读取到本地内存中,操作完成后再把本地内存的变量及时的写入主内存中 ####
-------
### JMM的主内存: ###
1. 存储java实例对象
2. 包括成员变量.类信息.常量.静态变量等
3. 属于数据共享的区域,多线程并发操作是会引发线程的安全问题

### JMM的工作内存 ###
1. 存储当前方法中的所有本地变量信息(其实就是从主内存的变量信息的拷贝),本地内存中的变量信息对其他线程是不可见的.
2. 字节码行号指示器,native方法信息
3. 属于线程私有数据区域,不存在线程安全问题

-----------
#### 主内存和工作内存的数据存储类型以及操作方式归纳: ####
1. 方法里的基本数据类型本地变量将直接存储到工作内存的栈帧结构中
2. 引用类型的本地变量:引用存储到工作内存中,实例存储在主内存中
3. 成员变量.static变量.类信息均会存储到主内存中
4. 主内存共享的方式是线程各拷贝一份数据到工作内存中,操作完成后刷新回主内存中

## 2.指令重排序需要满足的条件 ##
- 单线程环境下不能改变程序的运行结果
- 存在数据依赖关系的不允许重排序
#### 即:无法通过happens-before原则推导出来的,才能进行指令的重排序 ####
**happens-before:A操作的结果必须是对B操作可见,则A与B存在happens-before关系**
![](https://i.imgur.com/gTkb2Ny.png)
## 3.volatile :JVM提供的轻量级同步机制##
保证被volatile修饰的共享变量对所有线程总是可见的.禁止指令的重排序操作

### volatile变量为何立即可见? ###
- 当写一个volatile变量时,JMM会把该线程对应的工作内存中的共享变量值刷新到主内存中
- 当读一个volatile变量时,JMM会把该线程对应的工作内存置为无效(只能从主内存中进行读取)

### volatile如何禁止重排序优化 ###
**内存屏障(Memory Barrier)cpu指令**  
1.保证特定操作的执行顺序
2.保证某些变量的内存可见性

通过插入内存屏障指令来禁止在内存屏障前后的指令执行重排序优化  

强制刷新出各种cpu的缓存数据,因此任何在cpu上的线程都能读取到这些数据的最新版本

------
### volatile和synchronized的区别: ###
- volatile本质是告诉JVM当前变量在寄存器(工作内存)中的值是不确定的,需要去主内存就行读取;synchronized则是锁定当前变量,只有当前线程能对该变量进行操作,其他线程被阻塞直到该线程处理完毕
- volatile仅对变量使用,synchronized可以使用在变量和方法和类上
- volatile仅能实现对变量的修改可见性,并不保证原子性;而synchronized则可以保证变量修改的可见性和原子性
- volatile不会造成线程的阻塞;synchronized可能会造成线程对的阻塞
- volatile标记的变量不会被编译器优化的;synchronized标记的变量可以被编译器优化
