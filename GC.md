# GC(垃圾回收机制) #
2019-03-09 11:25:58 
## 1.判断对象是否为垃圾的算法 ##
**引用计数算法:**

1. 每个对象实例都有一个引用计数器,被引用一次就+1,完成引用就-1.
2. 每个实例对象的引用计数器为0,就可以把这个对象实例当做垃圾来处理

**优点:执行效率高,程序执行受影响小**  
**缺点:相互引用时无法使用,会导致内存泄露**

---
**引用可达性算法:**  
判断对象到GC Roots的引用链是否可达来决定是否为垃圾来处理

**可以作为GC Roots的对象:**

- 虚拟机栈的引用对象
- 方法区的常量引用对象
- 方法区的静态属性引用对象
- 本地方法(native方法)的引用对象
- 活跃线程的引用对象


## 2.垃圾回收算法 ##
### 2.1 标记-清除算法 ###
**标记:从根集合就行扫描,对需要回收的对象进行标记**  
**清除:对堆内存从头到尾进行线性遍历,回收不可达的垃圾对象**

*特点:会产生碎片化,会导致当堆内存需要分配一个大点的内存给实例对象时,由于找不到连续的内存分配,会提前触发一次垃圾回收*


### 2.2 复制算法(适用于年轻代) ###
**分为对象面和空闲面,对象在对象面创建,存活的对象从对象面复制到空闲面,将对象面的所有对象全部清除**

*特点:解决碎片化的问题,顺序分配内存空间,简单高效,适用于对象存活率低的场景*

### 2.3 标记-整理算法(适用于老年代) ###
**对所有需要回收的对象进行标记,然后统一将对象按照内存地址依次排序,然后把地址末尾已经标记需要回收的对象进行回收**

*特点:避免内存的不连续性及碎片化的产生,不需要设置一个空闲面节省了内存空间(有效利用了内存空间).适用于对象存活率高的场景*

### 2.4 分代收集 (主流垃圾回收算法)###
**按照对象的生命周期的不同划分到不同的区域采用不同的垃圾回收的算法进行垃圾回收**

## 3.GC分类 ##
GC的分类:

1. Minor GC:适用于新生代
2. Full GC:适用于老年代

**Full GC比Minor GC慢,但执行频率低**

---
年轻代(复制算法):尽可能快速的收集那些生命周期短的对象  
Eden区->8/10  
两个Survivor区->1/10,1/10

**年轻代占堆内存的1/3**

---
老年代(标记-清除,标记-整理):存放那些生命周期较长的对象

**老年代占堆内存的2/3**

---
### 3.1 对象如何从年轻代晋升到老年代? ###
1. 经过多次Minor GC任然存活的对象
2. 新生成的大对象
3. 年轻代的Survivor区内存不够的时候

### 3.2 GC的常用调优参数 ###
- **-XX:SurvivorRatio   :Eden区和Survivor区的比值大小.默认8:1**
- **-XX:NewRatio  :老年代和年轻代的比值大小**
- **-XX:MaxTenuringThreshold  :对象从年轻代晋升到老年代所经历的Minor GC的次数的最大值**

### 3.3 触发Full GC的条件? ###
1. 老年代的内存空间不足
2. 永久代的内存空间不足(jdk 7以下)
3. System.gc();
4. 经过MInor GC从年轻代晋升到老年代的对象的平均大小大于老年代的剩余内存空间
5. CMC GC出现Promotion failed,concurrent mode failure

### 3.4 JVM的运行模式 ###
server,client...  
server比client启动慢,但是稳定后,server运行速度快

## 4.垃圾收集器 ##
**年轻代的垃圾收集器**

Serial 收集器(复制算法):单线程收集,client模式下默认的年轻代GC收集器

ParNew 收集器(复制算法):多线程收集,在多核执行下才有优势

Parallel Scavenge(复制算法):多线程收集(更关注系统的吞吐量),server模式下默认的年轻代的GC收集器.  
吞吐量=(运行代码时间)/(代码运行时间+垃圾回收的时间)

---
**老年代的垃圾收集器**

Serial old 收集器(标记-整理算法):单线程收集,client模式下默认的老年代GC收集器

Parallel old 收集器(标记-整理算法):多线程收集,吞吐量优先考虑

CMC 收集器(标记-清除算法):a.初试标记.会产生stop-the-world ,终止所有线程的运行.b.并发标记,并发追溯标记.c.重新标记,会短暂的产生stw.d.并发清除,多线程并发清除老年代上的垃圾

---
G1 收集器(复制算法+标记-整理算法)

1. 并发和并行
2. 分代收集
3. 空间整合
4. 可预测的停顿

**G1收集器将整个堆区划分为多个大小相等的Region,年轻代和老年代不再是物理隔离了**

## 5.引用类型 ##
![](https://i.imgur.com/8DpDlxG.png)